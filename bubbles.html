<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubbles Visualization</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #search-box {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            width: 300px;
        }
        svg {
            display: block;
        }
        .bubble-text {
            fill: white;
            font-weight: bold;
            text-anchor: middle;
            pointer-events: none;
        }
    </style>
</head>
<body>

<input type="text" id="search-box" placeholder="Search...">

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
    const width = window.innerWidth;
    const height = window.innerHeight;

    const data = [
        { A: "Alpha", count: 10 },
        { A: "Beta", count: 15 },
        { A: "Gamma", count: 8 },
        { A: "Delta", count: 12 },
        { A: "Epsilon", count: 5 },
        { A: "Zeta", count: 14 },
        { A: "Eta", count: 7 },
        { A: "Theta", count: 10 },
        { A: "Iota", count: 11 },
        { A: "Kappa", count: 9 }
    ];

    const svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);

    const radiusScale = d3.scaleSqrt()
        .domain([5, 15])
        .range([20, 60]);

    // Define a radial gradient for 3D effect
    svg.append("defs")
        .append("radialGradient")
        .attr("id", "bubbleGradient")
        .attr("cx", "50%")
        .attr("cy", "50%")
        .attr("r", "50%")
        .attr("fx", "50%")
        .attr("fy", "50%")
        .selectAll("stop")
        .data([
            { offset: "0%", color: "#ffffff", opacity: 1 },
            { offset: "30%", color: "#1f77b4", opacity: 0.7 },
            { offset: "100%", color: "#1f77b4", opacity: 1 }
        ])
        .enter().append("stop")
        .attr("offset", d => d.offset)
        .attr("stop-color", d => d.color)
        .attr("stop-opacity", d => d.opacity);

    // Define a drop shadow filter
    svg.append("defs")
        .append("filter")
        .attr("id", "drop-shadow")
        .append("feGaussianBlur")
        .attr("in", "SourceAlpha")
        .attr("stdDeviation", 3)
        .attr("result", "blur");

    svg.select("#drop-shadow")
        .append("feOffset")
        .attr("in", "blur")
        .attr("dx", 2)
        .attr("dy", 2)
        .attr("result", "offsetBlur");

    svg.select("#drop-shadow")
        .append("feMerge")
        .selectAll("feMergeNode")
        .data(["offsetBlur", "SourceGraphic"])
        .enter().append("feMergeNode")
        .attr("in", d => d);

    const simulation = d3.forceSimulation(data)
        .force("x", d3.forceX(width / 2).strength(0.05))
        .force("y", d3.forceY(height / 2).strength(0.05))
        .force("collision", d3.forceCollide().radius(d => radiusScale(d.count) + 5))
        .force("charge", d3.forceManyBody().strength(-15))
        .on("tick", ticked);

    function ticked() {
        bubbles.attr("transform", d => `translate(${d.x},${d.y})`);
    }

    let bubbles = svg.selectAll(".bubble")
        .data(data, d => d.A)
        .enter().append("g")
        .attr("class", "bubble");

    bubbles.append("circle")
        .attr("r", d => radiusScale(d.count))
        .attr("fill", "url(#bubbleGradient)")
        .attr("stroke", "#1f77b4")
        .attr("stroke-width", 1)
        .style("filter", "url(#drop-shadow)");

    bubbles.append("text")
        .attr("class", "bubble-text")
        .attr("dy", ".3em")
        .text(d => d.A);

    d3.select("#search-box").on("input", function () {
        const searchTerm = this.value.toLowerCase();

        const filteredData = data.filter(d => d.A.toLowerCase().includes(searchTerm));

        svg.selectAll(".bubble").remove();

        simulation.nodes(filteredData)
            .force("x", d3.forceX(width / 2).strength(0.05))
            .force("y", d3.forceY(height / 2).strength(0.05))
            .force("collision", d3.forceCollide().radius(d => radiusScale(d.count) + 5))
            .alpha(1)
            .restart();

        bubbles = svg.selectAll(".bubble")
            .data(filteredData, d => d.A)
            .enter().append("g")
            .attr("class", "bubble");

        bubbles.append("circle")
            .attr("r", d => radiusScale(d.count))
            .attr("fill", "url(#bubbleGradient)")
            .attr("stroke", "#1f77b4")
            .attr("stroke-width", 1)
            .style("filter", "url(#drop-shadow)");

        bubbles.append("text")
            .attr("class", "bubble-text")
            .attr("dy", ".3em")
            .text(d => d.A);

        // Recenter bubbles
        simulation.on("tick", ticked);
    });

    // Continuous movement of bubbles
    simulation
        .force("x", d3.forceX().x(d => d.x))
        .force("y", d3.forceY().y(d => d.y))
        .velocityDecay(0.2); // Slower movement
</script>

</body>
</html>